{"ast":null,"code":"/**\r\n * Diffie-Hellman key exchange utility for secure image retrieval\r\n */\n\n// Constants\nconst DH_EXPIRATION_TIME = 60 * 60 * 1000; // 1 hour in milliseconds\nconst API_BASE_URL = \"http://localhost:8000/api/patients\";\n\n/**\r\n * Fetch Diffie-Hellman parameters from the server\r\n * @returns {Promise<Object>} The DH parameters (p, g, server_public_key)\r\n */\nexport const getDHParams = async () => {\n  try {\n    console.log(\"Fetching DH parameters from server\");\n    const response = await fetch(`${API_BASE_URL}/dh-params/`);\n    if (!response.ok) {\n      throw new Error(`Failed to get DH params: ${response.status}`);\n    }\n    const params = await response.json();\n    console.log(\"Received DH parameters:\", {\n      p: params.p,\n      g: params.g,\n      // Don't log the full server public key for security\n      serverPublicKeyReceived: !!params.server_public_key\n    });\n    return params;\n  } catch (error) {\n    console.error(\"Error fetching DH parameters:\", error);\n    throw error;\n  }\n};\n\n/**\r\n * Generate a client key pair and exchange with the server\r\n * @param {Object} params - The DH parameters from getDHParams()\r\n * @returns {Promise<Object>} Object containing clientId and sharedSecret\r\n */\nexport const exchangeKeys = async params => {\n  try {\n    // Generate client's private key (random number)\n    const clientPrivateKey = Math.floor(Math.random() * (params.p - 1)) + 1;\n\n    // Calculate client's public key\n    const clientPublicKey = Math.pow(params.g, clientPrivateKey) % params.p;\n    console.log(\"Generated client public key\");\n\n    // Send client's public key to server\n    console.log(\"Sending public key to server\");\n    const response = await fetch(`${API_BASE_URL}/dh-exchange/`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        client_public_key: clientPublicKey\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to exchange keys: ${response.status}`);\n    }\n    const {\n      client_id\n    } = await response.json();\n    console.log(\"Received client ID from server:\", client_id);\n\n    // Calculate shared secret using server's public key\n    const sharedSecret = Math.pow(params.server_public_key, clientPrivateKey) % params.p;\n    console.log(\"Calculated shared secret\");\n\n    // Hash the shared secret for actual use\n    const hashedSecret = hashString(sharedSecret.toString());\n    return {\n      clientId: client_id,\n      sharedSecret: hashedSecret\n    };\n  } catch (error) {\n    console.error(\"Error exchanging DH keys:\", error);\n    throw error;\n  }\n};\n\n/**\r\n * Simple hash function for the shared secret\r\n * Note: In production, use a proper cryptographic library\r\n * @param {string} str - The string to hash\r\n * @returns {string} The hashed string\r\n */\nconst hashString = str => {\n  // Simple SHA-256-like hash implementation\n  // In production, use a proper crypto library like crypto-js\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n};\n\n/**\r\n * Store DH credentials in localStorage with expiration timestamp\r\n * @param {string} clientId - The client ID from the server\r\n * @param {string} sharedSecret - The computed shared secret\r\n */\nexport const storeDHCredentials = (clientId, sharedSecret) => {\n  const credentials = {\n    clientId,\n    sharedSecret,\n    timestamp: Date.now()\n  };\n  localStorage.setItem(\"dh_credentials\", JSON.stringify(credentials));\n  console.log(\"DH credentials stored with expiration\");\n};\n\n/**\r\n * Get stored DH credentials from localStorage\r\n * @returns {Object|null} The stored credentials or null if not found or expired\r\n */\nexport const getStoredDHCredentials = () => {\n  const credentialsJson = localStorage.getItem(\"dh_credentials\");\n  if (!credentialsJson) {\n    return null;\n  }\n  try {\n    const credentials = JSON.parse(credentialsJson);\n\n    // Check if credentials have expired\n    if (Date.now() - credentials.timestamp > DH_EXPIRATION_TIME) {\n      console.log(\"DH credentials have expired, clearing them\");\n      clearDHCredentials();\n      return null;\n    }\n    return {\n      clientId: credentials.clientId,\n      sharedSecret: credentials.sharedSecret\n    };\n  } catch (err) {\n    console.error(\"Error parsing stored DH credentials:\", err);\n    clearDHCredentials();\n    return null;\n  }\n};\n\n/**\r\n * Clear stored DH credentials\r\n */\nexport const clearDHCredentials = () => {\n  localStorage.removeItem(\"dh_credentials\");\n};\n\n/**\r\n * Initialize DH authentication flow\r\n * @returns {Promise<Object>} The DH credentials\r\n */\nexport const initializeDHAuth = async () => {\n  try {\n    // Check if we already have stored credentials\n    const storedCreds = getStoredDHCredentials();\n    if (storedCreds) {\n      console.log(\"Using stored DH credentials\");\n      return storedCreds;\n    }\n    console.log(\"Initializing new DH authentication\");\n    // Otherwise, perform the full DH exchange\n    const dhParams = await getDHParams();\n    const {\n      clientId,\n      sharedSecret\n    } = await exchangeKeys(dhParams);\n\n    // Store the credentials for future use\n    storeDHCredentials(clientId, sharedSecret);\n    return {\n      clientId,\n      sharedSecret\n    };\n  } catch (error) {\n    console.error(\"Failed to initialize DH authentication:\", error);\n    throw error;\n  }\n};","map":{"version":3,"names":["DH_EXPIRATION_TIME","API_BASE_URL","getDHParams","console","log","response","fetch","ok","Error","status","params","json","p","g","serverPublicKeyReceived","server_public_key","error","exchangeKeys","clientPrivateKey","Math","floor","random","clientPublicKey","pow","method","headers","body","JSON","stringify","client_public_key","client_id","sharedSecret","hashedSecret","hashString","toString","clientId","str","hash","i","length","char","charCodeAt","storeDHCredentials","credentials","timestamp","Date","now","localStorage","setItem","getStoredDHCredentials","credentialsJson","getItem","parse","clearDHCredentials","err","removeItem","initializeDHAuth","storedCreds","dhParams"],"sources":["C:/perflogss/folder/New folder (5)/medical-lab-system/src/utils/diffieHellman.js"],"sourcesContent":["/**\r\n * Diffie-Hellman key exchange utility for secure image retrieval\r\n */\r\n\r\n// Constants\r\nconst DH_EXPIRATION_TIME = 60 * 60 * 1000; // 1 hour in milliseconds\r\nconst API_BASE_URL = \"http://localhost:8000/api/patients\";\r\n\r\n/**\r\n * Fetch Diffie-Hellman parameters from the server\r\n * @returns {Promise<Object>} The DH parameters (p, g, server_public_key)\r\n */\r\nexport const getDHParams = async () => {\r\n  try {\r\n    console.log(\"Fetching DH parameters from server\");\r\n    const response = await fetch(`${API_BASE_URL}/dh-params/`);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to get DH params: ${response.status}`);\r\n    }\r\n    const params = await response.json();\r\n    console.log(\"Received DH parameters:\", {\r\n      p: params.p,\r\n      g: params.g,\r\n      // Don't log the full server public key for security\r\n      serverPublicKeyReceived: !!params.server_public_key,\r\n    });\r\n    return params;\r\n  } catch (error) {\r\n    console.error(\"Error fetching DH parameters:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Generate a client key pair and exchange with the server\r\n * @param {Object} params - The DH parameters from getDHParams()\r\n * @returns {Promise<Object>} Object containing clientId and sharedSecret\r\n */\r\nexport const exchangeKeys = async (params) => {\r\n  try {\r\n    // Generate client's private key (random number)\r\n    const clientPrivateKey = Math.floor(Math.random() * (params.p - 1)) + 1;\r\n\r\n    // Calculate client's public key\r\n    const clientPublicKey = Math.pow(params.g, clientPrivateKey) % params.p;\r\n    console.log(\"Generated client public key\");\r\n\r\n    // Send client's public key to server\r\n    console.log(\"Sending public key to server\");\r\n    const response = await fetch(`${API_BASE_URL}/dh-exchange/`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ client_public_key: clientPublicKey }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to exchange keys: ${response.status}`);\r\n    }\r\n\r\n    const { client_id } = await response.json();\r\n    console.log(\"Received client ID from server:\", client_id);\r\n\r\n    // Calculate shared secret using server's public key\r\n    const sharedSecret =\r\n      Math.pow(params.server_public_key, clientPrivateKey) % params.p;\r\n    console.log(\"Calculated shared secret\");\r\n\r\n    // Hash the shared secret for actual use\r\n    const hashedSecret = hashString(sharedSecret.toString());\r\n\r\n    return {\r\n      clientId: client_id,\r\n      sharedSecret: hashedSecret,\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error exchanging DH keys:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Simple hash function for the shared secret\r\n * Note: In production, use a proper cryptographic library\r\n * @param {string} str - The string to hash\r\n * @returns {string} The hashed string\r\n */\r\nconst hashString = (str) => {\r\n  // Simple SHA-256-like hash implementation\r\n  // In production, use a proper crypto library like crypto-js\r\n  let hash = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    const char = str.charCodeAt(i);\r\n    hash = (hash << 5) - hash + char;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return hash.toString(16);\r\n};\r\n\r\n/**\r\n * Store DH credentials in localStorage with expiration timestamp\r\n * @param {string} clientId - The client ID from the server\r\n * @param {string} sharedSecret - The computed shared secret\r\n */\r\nexport const storeDHCredentials = (clientId, sharedSecret) => {\r\n  const credentials = {\r\n    clientId,\r\n    sharedSecret,\r\n    timestamp: Date.now(),\r\n  };\r\n  localStorage.setItem(\"dh_credentials\", JSON.stringify(credentials));\r\n  console.log(\"DH credentials stored with expiration\");\r\n};\r\n\r\n/**\r\n * Get stored DH credentials from localStorage\r\n * @returns {Object|null} The stored credentials or null if not found or expired\r\n */\r\nexport const getStoredDHCredentials = () => {\r\n  const credentialsJson = localStorage.getItem(\"dh_credentials\");\r\n\r\n  if (!credentialsJson) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const credentials = JSON.parse(credentialsJson);\r\n\r\n    // Check if credentials have expired\r\n    if (Date.now() - credentials.timestamp > DH_EXPIRATION_TIME) {\r\n      console.log(\"DH credentials have expired, clearing them\");\r\n      clearDHCredentials();\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      clientId: credentials.clientId,\r\n      sharedSecret: credentials.sharedSecret,\r\n    };\r\n  } catch (err) {\r\n    console.error(\"Error parsing stored DH credentials:\", err);\r\n    clearDHCredentials();\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear stored DH credentials\r\n */\r\nexport const clearDHCredentials = () => {\r\n  localStorage.removeItem(\"dh_credentials\");\r\n};\r\n\r\n/**\r\n * Initialize DH authentication flow\r\n * @returns {Promise<Object>} The DH credentials\r\n */\r\nexport const initializeDHAuth = async () => {\r\n  try {\r\n    // Check if we already have stored credentials\r\n    const storedCreds = getStoredDHCredentials();\r\n    if (storedCreds) {\r\n      console.log(\"Using stored DH credentials\");\r\n      return storedCreds;\r\n    }\r\n\r\n    console.log(\"Initializing new DH authentication\");\r\n    // Otherwise, perform the full DH exchange\r\n    const dhParams = await getDHParams();\r\n    const { clientId, sharedSecret } = await exchangeKeys(dhParams);\r\n\r\n    // Store the credentials for future use\r\n    storeDHCredentials(clientId, sharedSecret);\r\n\r\n    return { clientId, sharedSecret };\r\n  } catch (error) {\r\n    console.error(\"Failed to initialize DH authentication:\", error);\r\n    throw error;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}