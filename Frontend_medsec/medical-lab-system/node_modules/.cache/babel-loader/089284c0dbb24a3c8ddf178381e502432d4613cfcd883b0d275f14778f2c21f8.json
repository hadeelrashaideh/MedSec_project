{"ast":null,"code":"import * as forge from \"node-forge\";\n\n/**\r\n * Initialize Diffie-Hellman key exchange with server\r\n * @param {string} accessToken - JWT access token\r\n * @returns {Promise<Object>} - DH parameters and server public key\r\n */\nexport async function initializeKeyExchange(accessToken) {\n  const response = await fetch(\"http://localhost:8000/api/auth/key-exchange/\", {\n    method: \"GET\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": \"application/json\"\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Key exchange initialization failed: ${response.status}`);\n  }\n  return await response.json();\n}\n\n/**\r\n * Convert a string to BigInteger\r\n * @param {string} str - Numeric string to convert\r\n * @returns {forge.jsbn.BigInteger} - BigInteger object\r\n */\nfunction stringToBigInt(str) {\n  return new forge.jsbn.BigInteger(str);\n}\n\n/**\r\n * Generate a cryptographically secure random BigInteger\r\n * @param {forge.jsbn.BigInteger} max - Upper bound (exclusive)\r\n * @returns {forge.jsbn.BigInteger} - Random BigInteger\r\n */\nfunction generateRandomBigInt(max) {\n  // Create a byte array of appropriate length\n  const bitLength = max.bitLength();\n  const byteLength = Math.ceil(bitLength / 8);\n\n  // Generate random bytes\n  const randomBytes = forge.random.getBytesSync(byteLength);\n\n  // Convert to BigInteger and ensure it's less than max\n  const randomBigInt = new forge.jsbn.BigInteger(forge.util.bytesToHex(randomBytes), 16);\n\n  // Modulo to ensure value is in valid range\n  return randomBigInt.mod(max);\n}\n\n/**\r\n * Complete the Diffie-Hellman key exchange\r\n * @param {string} accessToken - JWT access token\r\n * @param {Object} dhParams - Parameters from initializeKeyExchange\r\n * @returns {Promise<string>} - Status message\r\n */\nexport async function completeKeyExchange(accessToken, dhParams) {\n  try {\n    // Parse parameters from server\n    const p = stringToBigInt(dhParams.params.p);\n    const g = stringToBigInt(dhParams.params.g);\n    const serverPublicKey = stringToBigInt(dhParams.server_public_key);\n\n    // Generate client's private key (keep this secret)\n    const clientPrivateKey = generateRandomBigInt(p);\n\n    // Calculate client's public key: g^privateKey mod p\n    const clientPublicKey = g.modPow(clientPrivateKey, p);\n\n    // Send client's public key to server\n    const response = await fetch(\"http://localhost:8000/api/auth/key-exchange/\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        client_public_key: clientPublicKey.toString()\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`Key exchange completion failed: ${response.status}`);\n    }\n\n    // Calculate shared secret (this is never transmitted)\n    const sharedSecret = serverPublicKey.modPow(clientPrivateKey, p);\n\n    // Derive AES key from shared secret using SHA-256\n    const md = forge.md.sha256.create();\n    md.update(sharedSecret.toString());\n    const aesKey = md.digest().toHex();\n\n    // Store the derived key securely (in memory/session storage, not localStorage)\n    sessionStorage.setItem(\"encryption_established\", \"true\");\n    console.log(\"Key exchange completed successfully\");\n    return await response.json();\n  } catch (error) {\n    console.error(\"Key exchange failed:\", error);\n    throw error;\n  }\n}\n\n/**\r\n * Refresh the encryption key\r\n * @param {string} accessToken - JWT access token\r\n * @returns {Promise<boolean>} - Whether refresh was successful\r\n */\nexport async function refreshEncryptionKey(accessToken) {\n  try {\n    const dhParams = await initializeKeyExchange(accessToken);\n    await completeKeyExchange(accessToken, dhParams);\n    console.log(\"Encryption key refreshed successfully\");\n    return true;\n  } catch (error) {\n    console.error(\"Failed to refresh encryption key:\", error);\n    return false;\n  }\n}\n\n/**\r\n * Set up periodic key refresh\r\n * @param {number} intervalMinutes - Minutes between refreshes\r\n * @returns {Function} - Cleanup function\r\n */\nexport function setupKeyRefresh(intervalMinutes = 60) {\n  // Clear any existing refresh intervals\n  if (window.keyRefreshInterval) {\n    clearInterval(window.keyRefreshInterval);\n  }\n\n  // Set up new refresh interval\n  window.keyRefreshInterval = setInterval(async () => {\n    const accessToken = localStorage.getItem(\"accessToken\");\n    if (!accessToken) {\n      clearInterval(window.keyRefreshInterval);\n      return;\n    }\n    await refreshEncryptionKey(accessToken);\n  }, intervalMinutes * 60 * 1000);\n\n  // Return cleanup function\n  return () => {\n    if (window.keyRefreshInterval) {\n      clearInterval(window.keyRefreshInterval);\n    }\n  };\n}","map":{"version":3,"names":["forge","initializeKeyExchange","accessToken","response","fetch","method","headers","Authorization","ok","Error","status","json","stringToBigInt","str","jsbn","BigInteger","generateRandomBigInt","max","bitLength","byteLength","Math","ceil","randomBytes","random","getBytesSync","randomBigInt","util","bytesToHex","mod","completeKeyExchange","dhParams","p","params","g","serverPublicKey","server_public_key","clientPrivateKey","clientPublicKey","modPow","body","JSON","stringify","client_public_key","toString","sharedSecret","md","sha256","create","update","aesKey","digest","toHex","sessionStorage","setItem","console","log","error","refreshEncryptionKey","setupKeyRefresh","intervalMinutes","window","keyRefreshInterval","clearInterval","setInterval","localStorage","getItem"],"sources":["C:/Users/USER/Desktop/medical-lab-system/medical-lab-system/src/services/cryptoService.js"],"sourcesContent":["import * as forge from \"node-forge\";\r\n\r\n/**\r\n * Initialize Diffie-Hellman key exchange with server\r\n * @param {string} accessToken - JWT access token\r\n * @returns {Promise<Object>} - DH parameters and server public key\r\n */\r\nexport async function initializeKeyExchange(accessToken) {\r\n  const response = await fetch(\"http://localhost:8000/api/auth/key-exchange/\", {\r\n    method: \"GET\",\r\n    headers: {\r\n      Authorization: `Bearer ${accessToken}`,\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`Key exchange initialization failed: ${response.status}`);\r\n  }\r\n\r\n  return await response.json();\r\n}\r\n\r\n/**\r\n * Convert a string to BigInteger\r\n * @param {string} str - Numeric string to convert\r\n * @returns {forge.jsbn.BigInteger} - BigInteger object\r\n */\r\nfunction stringToBigInt(str) {\r\n  return new forge.jsbn.BigInteger(str);\r\n}\r\n\r\n/**\r\n * Generate a cryptographically secure random BigInteger\r\n * @param {forge.jsbn.BigInteger} max - Upper bound (exclusive)\r\n * @returns {forge.jsbn.BigInteger} - Random BigInteger\r\n */\r\nfunction generateRandomBigInt(max) {\r\n  // Create a byte array of appropriate length\r\n  const bitLength = max.bitLength();\r\n  const byteLength = Math.ceil(bitLength / 8);\r\n\r\n  // Generate random bytes\r\n  const randomBytes = forge.random.getBytesSync(byteLength);\r\n\r\n  // Convert to BigInteger and ensure it's less than max\r\n  const randomBigInt = new forge.jsbn.BigInteger(\r\n    forge.util.bytesToHex(randomBytes),\r\n    16\r\n  );\r\n\r\n  // Modulo to ensure value is in valid range\r\n  return randomBigInt.mod(max);\r\n}\r\n\r\n/**\r\n * Complete the Diffie-Hellman key exchange\r\n * @param {string} accessToken - JWT access token\r\n * @param {Object} dhParams - Parameters from initializeKeyExchange\r\n * @returns {Promise<string>} - Status message\r\n */\r\nexport async function completeKeyExchange(accessToken, dhParams) {\r\n  try {\r\n    // Parse parameters from server\r\n    const p = stringToBigInt(dhParams.params.p);\r\n    const g = stringToBigInt(dhParams.params.g);\r\n    const serverPublicKey = stringToBigInt(dhParams.server_public_key);\r\n\r\n    // Generate client's private key (keep this secret)\r\n    const clientPrivateKey = generateRandomBigInt(p);\r\n\r\n    // Calculate client's public key: g^privateKey mod p\r\n    const clientPublicKey = g.modPow(clientPrivateKey, p);\r\n\r\n    // Send client's public key to server\r\n    const response = await fetch(\r\n      \"http://localhost:8000/api/auth/key-exchange/\",\r\n      {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${accessToken}`,\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          client_public_key: clientPublicKey.toString(),\r\n        }),\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Key exchange completion failed: ${response.status}`);\r\n    }\r\n\r\n    // Calculate shared secret (this is never transmitted)\r\n    const sharedSecret = serverPublicKey.modPow(clientPrivateKey, p);\r\n\r\n    // Derive AES key from shared secret using SHA-256\r\n    const md = forge.md.sha256.create();\r\n    md.update(sharedSecret.toString());\r\n    const aesKey = md.digest().toHex();\r\n\r\n    // Store the derived key securely (in memory/session storage, not localStorage)\r\n    sessionStorage.setItem(\"encryption_established\", \"true\");\r\n\r\n    console.log(\"Key exchange completed successfully\");\r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error(\"Key exchange failed:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Refresh the encryption key\r\n * @param {string} accessToken - JWT access token\r\n * @returns {Promise<boolean>} - Whether refresh was successful\r\n */\r\nexport async function refreshEncryptionKey(accessToken) {\r\n  try {\r\n    const dhParams = await initializeKeyExchange(accessToken);\r\n    await completeKeyExchange(accessToken, dhParams);\r\n    console.log(\"Encryption key refreshed successfully\");\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Failed to refresh encryption key:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Set up periodic key refresh\r\n * @param {number} intervalMinutes - Minutes between refreshes\r\n * @returns {Function} - Cleanup function\r\n */\r\nexport function setupKeyRefresh(intervalMinutes = 60) {\r\n  // Clear any existing refresh intervals\r\n  if (window.keyRefreshInterval) {\r\n    clearInterval(window.keyRefreshInterval);\r\n  }\r\n\r\n  // Set up new refresh interval\r\n  window.keyRefreshInterval = setInterval(async () => {\r\n    const accessToken = localStorage.getItem(\"accessToken\");\r\n\r\n    if (!accessToken) {\r\n      clearInterval(window.keyRefreshInterval);\r\n      return;\r\n    }\r\n\r\n    await refreshEncryptionKey(accessToken);\r\n  }, intervalMinutes * 60 * 1000);\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    if (window.keyRefreshInterval) {\r\n      clearInterval(window.keyRefreshInterval);\r\n    }\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}